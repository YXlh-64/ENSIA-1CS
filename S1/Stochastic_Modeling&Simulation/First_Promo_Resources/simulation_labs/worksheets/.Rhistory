u <- runif(1)
if (u < p) {
B[i] <- B[i-1] + 1
} else {
B[i] <- B[i-1]
}
}
return(B)
}
y<- binomial(1/4,40)
y
Bin <- function(size,n,p){
x <- c()
for(i in 1:size){
x[i] <- sum(runif(n)<p)
}
}
X <- Bin(10^4,40,1/4)
y<- binomial(1/4,10)
x1 <- binomial(1/4,10^4)
Bin <- function(size,n,p){
x <- c()
for(i in 1:size){
x[i] <- sum(runif(n)<p)
}
}
X <- Bin(10^4,10,1/4)
chisq.test(table(x1),p=dbinom(0:10,40,1/4))
y<- binomial(1/4,10)
x1 <- binomial(1/4,10^4)
Bin <- function(size,n,p){
x <- c()
for(i in 1:size){
x[i] <- sum(runif(n)<p)
}
}
X <- Bin(10^4,10,1/4)
chisq.test(table(X),p=dbinom(0:10,40,1/4))
Bin <- function(size,n,p){
x <- c()
for(i in 1:size){
x[i] <- sum(runif(n)<p)
}
}
X <- Bin(10^4,10,1/4)
# Plot histogram for the generated binomial distribution
hist(X, nclass = 10, col = "green", main = "Binomial Distribution n=10^4, p=1/4")
#qst 6 : poisson dist
poisson <- function(lambda,n){
x <- numeric(n)
for (i in 1:n){
k <- 0
p <- exp(-lambda)
u <- runif(1)
f <- p
while(u>f){
k = k+1
p <- (lambda / k) * p
f <-  f+p
}
x [i] <- k
}
return (x)
}
x1 <- poisson(5,10^4)
#test
# Plot histogram for the generated binomial distribution
hist(x1, nclass = 10, col = "pink", main = "poisson Distribution n=10^4, lambda=5")
# Plot histogram for a theoretical binomial distribution with the same parameters
hist(rpois(10^4,5), add = TRUE, col = "purple", breaks = 10)
lambda=2
i=0
u = runif(1)
y= (-1/lambda)*log(u)
sum =y
while(sum<1){ #here t=1 so sum<1
u = runif(1)
sum = sum +y
i=i+1
}
X =i
X
lambda=2
i=0
u = runif(1)
y= (-1/lambda)*log(u)
sum =y
while(sum<1){ #here t=1 so sum<1
u = runif(1)
sum = sum +y
i=i+1
}
X =i
X
results <- ks.test(x1, "ppois", 5)
print((p_value <- results$p.value))
alpha_theoretical <- 0.05
if (p_value > alpha_theoretical) {
print("X follows the same Poisson distribution; can't reject the null hypothesis")
} else {
print("X does not follow the same distribution")
}
# for n=12 uniform distribution we generate a variable x
normale <- function(m,n,std,mean){
x <-  numeric(m)
for(j in 1:m){
somme_u <- 0
for (i in 1:n)
{
u <- runif(n)
somme_u = sum(u)
}
x[j] <- ((somme_u - (n/2))*std*sqrt(12/n))+ mean
}
return (x)
}
X <- normale(10^4,12,2,2)
X
n= 5000
U1= runif(n)
U2 = runif(n)
Z1 = sqrt(-2*log(U1))*cos(2*pi*U2)
Z2 = sqrt(-2*log(U1))*sin(2*pi*U2)
hist(Z1, label = T)
Z1
z2
Z2
hist(Z1, label = T)
# Perform the Kolmogorov-Smirnov test between the two binomial distributions
results <- ks.test(X, "pnorm",2,2 )
print((p_value <- results$p.value))
alpha_theoretical <- 0.05
if (p_value > alpha_theoretical) {
print("X follows the same Normal distribution; can't reject the null hypothesis")
} else {
print("X does not follow the same distribution")
}
# Plot histogram for the generated binomial distribution
hist(X, nclass = 20, col = "blue", main = "normal Distribution std=2, mean=2")
# Plot histogram for a theoretical binomial distribution with the same parameters
hist(rnorm(10^4,mean=2,sd=2), add = TRUE, col = "yellow", breaks = 20)
Z1
# generate a vector of n normal distibuted varibales
NormalDist = function(n){
u1 = runif(n)
u2 = runif(n)
Z1 = (-2*log(u1))^0.5*cos(2*pi*u2)
return (Z1)
}
VecteurGaussien <- function(mean, C, n){
# Get the number of variables from the length of the mean vector
num_vars <- length(mean)
# Cholesky decomposition of the covariance matrix
chol_decomp <- chol(C)
# generates a matrix where each column corresponds to a different standard normal rv, and there are n observations for each variable.
normal_matrix <- sapply(1:num_vars, function(x) NormalDist(n))
# performs the matrix multiplication of the Cholesky decomposition with the transposed random matrix.
transformed_matrix <- t(t(chol_decomp) %*% t(normal_matrix))
# and add the mean vector to each observation
for(i in 1:n){
transformed_matrix[i,] <- transformed_matrix[i,] + mean
}
print(cov(normal_matrix))
print(colMeans(normal_matrix))
return(transformed_matrix)
}
mean <- c(1, 1, 2)
covariance <- matrix(c(1, 1, 3,
1, 4, 4,
3, 4, 11), nrow=3, byrow=TRUE)
observations <- VecteurGaussien(mean, covariance, 10)
print(cov(observations))
print(colMeans(observations))
P <- matrix(c(1/4, 1/2, 1/4,
1/3, 1/3, 1/3,
1/2, 1/4, 1/4), nrow=3, byrow=TRUE)
p
print(cov(observations))
print(cov(observations))
# generate a vector of n normal distibuted varibales
NormalDist = function(n){
u1 = runif(n)
u2 = runif(n)
Z1 = (-2*log(u1))^0.5*cos(2*pi*u2)
return (Z1)
}
VecteurGaussien <- function(mean, C, n){
# Get the number of variables from the length of the mean vector
num_vars <- length(mean)
# Cholesky decomposition of the covariance matrix
chol_decomp <- chol(C)
# generates a matrix where each column corresponds to a different standard normal rv, and there are n observations for each variable.
normal_matrix <- sapply(1:num_vars, function(x) NormalDist(n))
# performs the matrix multiplication of the Cholesky decomposition with the transposed random matrix.
transformed_matrix <- t(t(chol_decomp) %*% t(normal_matrix))
# and add the mean vector to each observation
for(i in 1:n){
transformed_matrix[i,] <- transformed_matrix[i,] + mean
}
print(cov(normal_matrix))
print(colMeans(normal_matrix))
return(transformed_matrix)
}
mean <- c(1, 1, 2)
covariance <- matrix(c(1, 1, 3,
1, 4, 4,
3, 4, 11), nrow=3, byrow=TRUE)
observations <- VecteurGaussien(mean, covariance, 10)
observations
print(cov(observations))
print(variance(observations))
print(covariance(observations))
print(cov(observations))
print(colMeans(observations))
printn(mean(observations))
print(colMeans(observations))
print(cov(observations))
observations
observations <- VecteurGaussien(mean, covariance, 1000)
observations
print(colMeans(observations))
print(cov(observations))
queue<-function(lambda,mu,npersons){
total_time =0
n=0 # for the state
num_arrivals=0
while (num_arrivals<npersons) {
#the time until the next event occurs in the system (arrival or dep)
time = rexp(1,lambda+mu)
u = runif(1,0,1)
total_time= total_time+time
if(u<(lambda/(lambda+mu))){
n=n+1
num_arrivals=num_arrivals+1
print(paste(n,total_time))
}else{
if(n>0){
n=n-1
print(paste(n,total_time))
}else{
n=n+1
print(paste(n,total_time))
}
}
}
}
queue(0.9,1,2000)
queue(2,1,2000)
observations
print(colMeans(observations))
queue<-function(lambda,mu,npersons){
total_time =0
n=0 # for the state
num_arrivals=0
while (num_arrivals<npersons) {
#the time until the next event occurs in the system (arrival or dep)
time = rexp(1,lambda+mu)
u = runif(1,0,1)
total_time= total_time+time
if(u<(lambda/(lambda+mu))){
n=n+1
num_arrivals=num_arrivals+1
print(paste(n,total_time))
}else{
if(n>0){
n=n-1
print(paste(n,total_time))
}else{
n=n+1
print(paste(n,total_time))
}
}
}
plot(time_values, n_values, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
queue(2,1,2000)
queue<-function(lambda,mu,npersons){
total_time =0
n=0 # for the state
num_arrivals=0
while (num_arrivals<npersons) {
#the time until the next event occurs in the system (arrival or dep)
time = rexp(1,lambda+mu)
u = runif(1,0,1)
total_time= total_time+time
if(u<(lambda/(lambda+mu))){
n=n+1
num_arrivals=num_arrivals+1
print(paste(n,total_time))
}else{
if(n>0){
n=n-1
print(paste(n,total_time))
}else{
n=n+1
print(paste(n,total_time))
}
}
}
plot(total_time, n, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
queue(2,1,2000)
plot(total_time, n, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
#EXo 3:
queue<-function(lambda,mu,npersons){
total_time =0
n=0 # for the state
num_arrivals=0
while (num_arrivals<npersons) {
#the time until the next event occurs in the system (arrival or dep)
time = rexp(1,lambda+mu)
u = runif(1,0,1)
total_time= total_time+time
if(u<(lambda/(lambda+mu))){
n=n+1
num_arrivals=num_arrivals+1
print(paste(n,total_time))
}else{
if(n>0){
n=n-1
print(paste(n,total_time))
}else{
n=n+1
print(paste(n,total_time))
}
}
}
plot(total_time, n, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
queue(2,1,2000)
queue <- function(lambda, mu, npersons) {
total_time <- 0
n <- 0
num_arrivals <- 0
# Create empty vectors to store data
n_values <- numeric(npersons)
time_values <- numeric(npersons)
while (num_arrivals < npersons) {
time <- rexp(1, lambda + mu)
u <- runif(1, 0, 1)
total_time <- total_time + time
if (u < (lambda / (lambda + mu))) {
n <- n + 1
num_arrivals <- num_arrivals + 1
} else {
if (n > 0) {
n <- n - 1
} else {
n <- n + 1
}
}
# Store values at each iteration
n_values[num_arrivals] <- n
time_values[num_arrivals] <- total_time
}
# Plot the data
plot(time_values, n_values, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
# Run the simulation and plot the results
queue(2, 1, 2000)
# Run the simulation and plot the results
queue(0.9, 1, 2000)
# Run the simulation and plot the results
queue(2, 1, 2000)
covariance <- matrix(c(1, 1, 3,
1, 4, 4,
3, 4, 11), nrow=3, byrow=TRUE)
covariance
mean <- c(1, 1, 2)
mean
covariance + mean
queue <- function(lambda, mu, npersons, n_executions ) {
for (i in 1:n_executions) {
total_time <- 0
n <- 0
num_arrivals <- 0
# Create empty vectors to store data
n_values <- numeric(npersons)
time_values <- numeric(npersons)
while (num_arrivals < npersons) {
time <- rexp(1, lambda + mu)
u <- runif(1, 0, 1)
#la somme cummulative d'un arrivé et le resultat de time(inter arrival time)et le total_time (the time of the arrival of the next customer)
total_time <- total_time + time
if (u < (lambda / (lambda + mu))) {
n <- n + 1
num_arrivals <- num_arrivals + 1
} else {
if (n > 0) {
n <- n - 1
} else {
n <- n + 1
}
}
# Store values at each iteration
n_values[num_arrivals] <- n
time_values[num_arrivals] <- total_time
}
# Plot the data
plot(time_values, n_values, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
average_response_time = total_time / n_executions
print(average_response_time)
}
# Run the simulation and plot the results
queue(0.9, 1, 2000,200)
queue <- function(lambda, mu, npersons ) {
total_time <- 0
n <- 0
num_arrivals <- 0
# Create empty vectors to store data
n_values <- numeric(npersons)
time_values <- numeric(npersons)
while (num_arrivals < npersons) {
time <- rexp(1, lambda + mu)
u <- runif(1, 0, 1)
#la somme cummulative d'un arrivé et le resultat de time(inter arrival time)et le total_time (the time of the arrival of the next customer)
total_time <- total_time + time
if (u < (lambda / (lambda + mu))) {
n <- n + 1
num_arrivals <- num_arrivals + 1
} else {
if (n > 0) {
n <- n - 1
} else {
n <- n + 1
}
}
# Store values at each iteration
n_values[num_arrivals] <- n
time_values[num_arrivals] <- total_time
}
# Plot the data
plot(time_values, n_values, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
# Run the simulation and plot the results
queue(0.9, 1, 2000)
queue(0.9, 1, 2000)
queue <- function(lambda, mu, npersons ) {
total_time <- 0
n <- 0
num_arrivals <- 0
# Create empty vectors to store data
n_values <- numeric(npersons)
time_values <- numeric(npersons)
while (num_arrivals < npersons) {
time <- rexp(1, lambda + mu)
u <- runif(1, 0, 1)
#la somme cummulative d'un arrivé et le resultat de time(inter arrival time)et le total_time (the time of the arrival of the next customer)
total_time <- total_time + time
if (u < (lambda / (lambda + mu))) {
n <- n + 1
num_arrivals <- num_arrivals + 1
} else {
if (n > 0) {
n <- n - 1
} else {
n <- n + 1
}
}
# Store values at each iteration
n_values[num_arrivals] <- n
time_values[num_arrivals] <- total_time
}
# Plot the data
plot(time_values, n_values, type = "s", col = "blue",
xlab = "Total Time", ylab = "Number in System",
main = "Queue Simulation")
}
#
# Run the simulation and plot the results
queue(0.9, 1, 2000)
# Run the simulation and plot the results
queue(2, 1, 2000)
P <- matrix(c(1/4, 1/2, 1/4,
1/3, 1/3, 1/3,
1/2, 1/4, 1/4), nrow=3, byrow=TRUE)
P
# Run the simulation and plot the results
queue(0.9, 1, 2000)
# Run the simulation and plot the results
queue(0.9, 1, 20)
# Run the simulation and plot the results
queue(2, 1, 20)
# Run the simulation and plot the results
queue(0.9, 1, 20)
# Run the simulation and plot the results
queue(0.9, 1, 2000)
# Run the simulation and plot the results
queue(2, 1, 2000)
PI <- c(1,0,0)
PI
M <- c()
for (i in 1:1000){
x = rnorm(i,5,1)
M[i] = mean(X)
}
M
